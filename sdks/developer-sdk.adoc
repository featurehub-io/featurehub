= Developer SDK Documentation

So you want to write an SDK? That's awesome, thanks for joining the crew!


== What to know up front
There are a few things you need to know up front.

=== Server Sent Events

The key to the Feature Hub SDK is that all clients should receive updates at the same time. In the perfect world, this means
all of your stack updates instantly with your configured updates - backend and front-end. We ideally want to take
advantage of caching at CDN layers if we can.

To achieve this, there are only three technologies available across the major platforms that they have in common, plain
old HTTP, Server Sent Events, and Web Sockets. Lets brush HTTP/2 and HTTP/3 (QUIC) under the table for the time being. 

At its core, HTTP is a connectionless protocol, even with Keep-Alive, it is client driven protocol. Not suitable for
our stated goal. It is great for being able 

WebSockets is essentially bi-directional tcp overlaid on the HTTP layer and it suffers a few problems for our use case.
It isn't cachable, requires considerably greater complexity in terms of client implementation, and it is bi-directional,
which isn't really necessary in our case.

That leaves us with one thing left, and funnily enough, it was designed exactly for the kind of problem we are trying
to solve. Server Sent Events came out in 2006 and is very widely supported in both the browser space (except for IE, 
which requires a polyfill) and through many client libraries. Further it is focused on server-push, is cachable, 
allowing you to use clever CDN's like https://www.fastly.com/blog/server-sent-events-fastly[Fastly].

What is even better about SSE is that you can simply use `curl`, your normal browser inspection tools, and our
implementation of it is very easy to use and understand.

The downsides of it, as mentioned in that post by Fastly, are the same as with WebSockets. It keeps a radio link open
and so you shouldn't use it for Mobile without connecting and disconnecting.

Further information on SSE:

- https://en.wikipedia.org/wiki/Server-sent_events[Wikipedia]
- https://docs.servicestack.net/server-events[Service Stack]


=== OpenAPI

We use an OpenAPI definition for the SSE layer. Hold on you say, OpenAPI is a REST/JSON-RPC standard, it doesn't support
SSE. Yes, you would be right, it doesn't support WebSockets either. However, there is one REST call in the API, and
all of the data structures that are sent over the wire are listed in that document. It is merged from several files,
but essentially looks like this:

[source,yaml]
----
openapi: 3.0.1
info: {title: FeatureServiceApi, description: This describes the API clients use for accessing features,
       version: 1.1.1}
paths:
  /features/{sdkUrl}/{featureKey}:
    put:
      tags: [FeatureService]
      parameters:
        - name: sdkUrl
          in: path
          description: The SDK key for the environment and service account
          schema: {type: string}
        - name: featureKey
          in: path
          description: The key you wish to update/action
          schema: {type: string}
      requestBody:
        content:
          application/json:
            schema: {$ref: '#/components/schemas/FeatureStateUpdate'}
      description: Gets a list of features and their states. This is not accurate as it returns a text/event-stream.
      operationId: setFeatureState
      responses:
        '200':
          description: gets all of the features
          content:
            application/json:
              schema:
                type: array
                items: {$ref: '#/components/schemas/FeatureState'}
components:
  schemas:
    FeatureValueType:
      type: string
      enum: [BOOLEAN, STRING, NUMBER, JSON]
    RoleType:
      type: string
      enum: [READ, LOCK, UNLOCK, CHANGE_VALUE]
    FeatureStateUpdate:
      type: object
      properties:
        value: {description: the new value}
        updateValue: {type: boolean, description: 'indicates whether you are trying
            to update the value, as value can be null'}
        lock: {description: 'set only if you wish to lock or unlock, otherwise null',
               type: boolean}
    SSEResultState:
      type: string
      enum: [ack, bye, failure, features, feature, delete_feature]
    FeatureState:
      required: [name]
      properties:
        id: {type: string}
        key: {type: string}
        version: {type: integer, format: int64}
        type: {$ref: '#/components/schemas/FeatureValueType'}
        value: {description: the current value}
        strategy: {$ref: '#/components/schemas/Strategy'}
    Strategy:
      required: [name]
      properties:
        name: {$ref: '#/components/schemas/StrategyNameType'}
        value: {description: this value is used if it is a simple attribute or percentage. If it is more complex then the pairs are passed}
        pairs:
          type: array
          items: {$ref: '#/components/schemas/StrategyPair'}
    StrategyNameType:
      type: string
      enum: [ATTRIBUTE, PERCENTAGE]
    StrategyPair:
      required: [name]
      properties:
        name: {type: string}
        value: {type: string}


----

You will notice the eventsource url is missing, and it is. If you use the standard 
https://github.com/OpenAPITools/openapi-generator[OpenAPI generator] as supported by the community, then you will
generally get a passable API. If you are having difficulty with it, please let us know - we have expertise in making
it work well.

== SDK submissions

From our perspective, we are happy to accept any contributions within our guidelines and that follow the basic requirements
of the SDK pattern we have established. It is fine that they are delivered in stages, we just ideally want to keep the
key functions the same between the different languages. 

It is worthwhile they be idiomatic to your language.


=== Special thanks

To one of our contributors https://github.com/chrusty[`@chrusty`] for prompting us for the need for this documentation
