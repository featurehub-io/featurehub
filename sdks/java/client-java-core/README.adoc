= Java Client SDK for FeatureHub
ifdef::env-github,env-browser[:outfilesuffix: .adoc]

Welcome to the Java SDK implementation for https://featurehub.io[FeatureHub.io] - Open source Feature flags management, A/B testing and remote configuration platform.

Below explains how you can use the FeatureHub SDK in Java for Java backend applications or Android mobile
applications.

To control the feature flags from the FeatureHub Admin console, either use our [demo](https://demo.featurehub.io) version for evaluation or install the app using our guide [here](http://docs.featurehub.io/#_installation)

There are 2 ways to request for feature updates via this SDK:

- **SSE (Server Sent Events) realtime updates mechanism**

In this mode, you will make a connection to the FeatureHub Edge server using an EventSource library which this SDK is based on, and any updates to any features will come through to you in near realtime, automatically updating the feature values in the repository. This is always the recommended method for backend applications, and
we have an implementation in Jersey. 

- **FeatureHub GET client (GET request updates)**

In this mode, you make a GET request, which you control how often it runs. The SDK provides no timer based
repeat functionality to keep making this request. There is an implementation using OKHttp. We have
deliberately left the timer choice to you as there are many different timer functions, including one built into
the JDK (`java.util.Timer`).

== SDK Installation

To install the SDK, choose your method of connection. The Core library will be included transitively. The
Core library uses Java Service Loaders to automatically discover what client library you have chosen, so please
ensure you include only one.

- **SSE (Server Sent Events) realtime updates mechanism**

[source,xml]
----
    <dependency>
      <groupId>io.featurehub.sdk</groupId>
      <artifactId>java-client-jersey</artifactId>
      <version>[2.1,3)</version>
    </dependency>
----

If you do not already use Jersey in your code base, you should also include our runtime dependencies for Jersey
and Jackson.

[source,xml]
----
    <dependency>
      <groupId>io.featurehub.composites</groupId>
      <artifactId>composite-jersey</artifactId>
      <version>[1.1, 2)</version>
    </dependency>
----

- **FeatureHub polling client (GET request updates)**

[source,xml]
----
    <dependency>
      <groupId>io.featurehub.sdk</groupId>
      <artifactId>java-client-jersey</artifactId>
      <version>[2.1,3)</version>
    </dependency>
----


## Quick start

### Connecting to FeatureHub
There are 4 steps to connecting:
1) Copy FeatureHub API Key from the FeatureHub Admin Console
2) Use the API Key to make a client
3) Check FeatureHub Repository readyness and request feature state

#### 1. Copy SDK API Key from the FeatureHub Admin Console
Find and copy your SDK API Key from the FeatureHub Admin Console on the Service Accounts Keys page -
you will use this in your code to configure feature updates for your environments.
It should look similar to this: `default/71ed3c04-122b-4312-9ea8-06b2b8d6ceac/fsTmCrcZZoGyl56kPHxfKAkbHrJ7xZMKO3dlBiab5IqUXjgKvqpjxYdI8zdXiJqYCpv92Jrki0jY5taE`.

There are two options - a Server Evaluated API Key and a Client Evaluated API Key. More on this https://docs.featurehub.io/#_client_and_server_api_keys[here]

Client Side evaluation is intended for use in secure environments (such as microservices) 
and is intended for rapid client side evaluation, per request for example.

Server Side evaluation is more suitable when you are using an _insecure client_. (e.g. Browser or Mobile). 
This also means you evaluate one user per client.

#### 2. Make a client:

Create an instance of `EdgeFeatureHubConfig`. You need to provide the API Key and the URL of the end-point you will be connecting to (the Edge server URL).

[source,java]
----
import io.featurehub.client.EdgeFeatureHubConfig;

String edgeUrl = "http://localhost:8085/";
String apiKey = "/default/71ed3c04-122b-4312-9ea8-06b2b8d6ceac/fsTmCrcZZoGyl56kPHxfKAkbHrJ7xZMKO3dlBiab5IqUXjgKvqpjxYdI8zdXiJqYCpv92Jrki0jY5taE";

FeatureHubConfig fhConfig = new EdgeFeatureHubConfig(edgeUrl, apiKey);
----

#### 3. Check FeatureHub Repository readyness and request feature state

Feature flag rollout strategies and user targeting are all determined by the active _user context_. If you are not intending to use rollout strategies, you can pass empty context to the SDK.

**Client Side evaluation**

What you do next depends on your framework. In many modern frameworks, you don't get to choose when
the server starts, it starts and you just have deal with it. It is recommended that you ensure that your heartbeat
or readyness check is dependent on whether the feature service is connected.

You would typically have a dependency injection system (like Spring or CDI) looking after you, to inject the
FeatureHubConfig you created above. In this case, we recommend you simply add into your liveness or heartbeat
check:

[source,java]
----
if (fhConfig.repository().getReadyness() != Readyness.Ready) {
  throw new <insert exception here>();
}
----

This will prevent most services like Application Load Balancers or Kubernetes from routing traffic to your
server before it has connected to the feature service and is ready.

There are other ways to do this, but this is the most strongly recommended because it ensures that
a system in a properly structured Java service will behave as expected.

The next thing you would normally do is to ensure that the `ClientContext` is ready and set up for downstream
systems to get a hold of and use. In Java this is normally done by using a `filter` and providing some 
kind of _request level scope_ - a Request Level injectable object. 


**Server side evaluation**

In the server side evaluation (e.g. browser app) the context is created once as you evaluate one user per client.

----
const fhContext = await fhConfig.newContext().build();
let initialized = false;

// taken from the React example
fhConfig.repository().addReadynessListener((readyness) => {
  if (!initialized) {
    if (readyness === Readyness.Ready) {
      initialized = true;
      const color = fhContext.getString('FEATURE_BUTTON_COLOR');
      this.setState({todos: this.state.myapp.changeButtonColor(color)});
    }
  }
});
----


Welcome to the Java implementation for FeatureHub.

Visit our official web page for more information about the platform https://www.featurehub.io/[here]

== Overview

This is the core library for Java.

It provides the core functionality of the `ClientContext` through which you will interact with features 
and log analytical events.

This library does not hold any code that connects to the Edge Server for FeatureHub. Because of thee wide
world of Java, there are many different libraries that can do that in a number of different ways. We provide
two - one using okhttp and another that uses Server Sent Events using  

As that will depend on whatever HTTP client java library you use, we have provided one for Jersey.
We expect to provide future libraries for various other popular HTTP libraries.

This library only provides one recommended type of operation, which is that the server will update all the features
all of the time.

NOTE: This readme does not deal with the SDK capability of updating features while running your tests. That
capability is API client specific, and the sample we have is for Jersey. link:../client-java-jersey/README{outfilesuffix}[It is documented here.]

== Using the Java Feature SDK

Because this is the Java SDK, and it can be used in a back-end service or Android, there are two ways of
interacting with this service. Only one is currently supported and is not recommended for Android as
it keeps the radio on. This will come in later in our roadmap.

=== 1. All the Features, All the Time

In this mode, you will make a connection to the FeatureHub Edge server, and any updates to any events will come
through to you, updating the feature values in the repository. You can choose to listen for these updates and update
some UI immediate, but every `if` statement will indicate the updated value, so listening is usually a better choice.

A typical strategy will be:

. create a feature hub repository, wire it into your application stack as appropriate.
. set up and wire up your application. initialize your server, but don't start it.
. set up a readyness listener so you know when the features have loaded and you have an initial state for them. When
you get a `Ready` state, start the server listening. If you get a `Failed` then shut your server down or continue
without a set of features.
. [optional] set up your per feature listeners so you can react to their changes in state. You can operate
in a imperative (is this feature on?) and/or reactive (callback) way with the repository.

This kind of operation is perfect for servers.It can lead to instant change which could confuse users in a UI and
isn't something our team recommends.

An example using our Jersey client.

[source,java]
----
ClientFeatureRepository cfr = new ClientFeatureRepository(5);

// the static feature context is a convenience interface 
StaticFeatureContext.repository = cfr;

// configure and immediately connect and attempt to listen
new JerseyClient(featureHubUrl, true, cfr);

// ... 

final HttpServer server = GrizzlyHttpServerFactory.createHttpServer(BASE_URI, config, false);

cfr.addReadynessListener((ready) -> {
  if (ready == Readyness.Ready) {
    try {
      server.start();
    } catch (IOException e) {
      log.error("Failed to start", e);
      throw new RuntimeException(e);
    }

    log.info("Application started. (HTTP/2 enabled!) -> {}", BASE_URI);
  } else if (ready == Readyness.Failed) {
    server.shutdownNow(); // probably should wait in case we have inflight connections
    log.error("Connect to feature server failed, shutting down server.");
    System.exit(-1);
  }
});
----


NOTE: You will only get a Failed later if your connection drops out. You can choose to ignore the Failure
if you already have your features and deal with it by instantiating a new client. It won't generate a failure
if the server has simply booted you off due to a timeout, only because of connection failure.


==== Local Feature Overrides

If you set a system property `feature-toggles.FEATURE_NAME` then you can override the value of what the value
is for feature flags. This is a further convenience feature and can be useful for an individual developer 
working on a new feature, where it is off for everyone else but not for them.


== Analytics

The Analytics client layer currently only supports directly exporting data to 
https://docs.featurehub.io/#_google_analytics_integration[Google Analytics]. It has the capability to add further
adapters but this is not our medium term strategy to do it this way. 

To configure it, you need three things:

- a Google analytics key - usually in the form UA-
- [optional] a CID - a customer id this is associate with this. We recommend you set on for the server
and override it if you know what you are tracking against for the individual request.
- a client implementation. We provide one for Jersey currently.

[source,java]
----
cfr.addAnalyticCollector(new GoogleAnalyticsCollector(analyticsKey, analyticsCid, new GoogleAnalyticsJerseyApiClient()));
----

When you wish to lodge an event, simply call `logAnalyticsEvent` on the featurehub repository instance. You can
simply pass the event, or you can pass the event plus some extra data, including the overridden CID and a `gaValue`
for the value field in Google Analytics.

== Using the library

This is just a repository, it needs something to fill it and currently we support Jersey. If you wish to write your
own or fill it with properties or such, you can use the artifact as is. In Maven-speak this is:

[source,xml]
----
    <dependency>
      <groupId>io.featurehub.sdk</groupId>
      <artifactId>java-client-core</artifactId>
      <version>1.2</version>
    </dependency>
----

Alternatively we recommend version ranges:


[source,xml]
----
    <dependency>
      <groupId>io.featurehub.sdk</groupId>
      <artifactId>java-client-core</artifactId>
      <version>[1.1,2)</version>
    </dependency>
----


Note that we indicate jackson as a provided dependency because most clients will have it already and we do not
wish to dictate our own. However, if you do not have a jackson dependency, please also include:

[source,xml]
----
    <dependency>
      <groupId>io.featurehub.composites</groupId>
      <artifactId>composite-jackson</artifactId>
      <version>[1.1, 2)</version>
    </dependency>
----

== Rollout Strategies

Starting from version 1.1.0 FeatureHub supports _server side_ evaluation of complex rollout strategies
that are applied to individual feature values in a specific environment. This includes support of preset rules, e.g. per **_user key_**, **_country_**, **_device type_**, **_platform type_** as well as **_percentage splits_** rules and custom rules that you can create according to your application needs.

For more details on rollout strategies, targeting rules and feature experiments see the https://docs.featurehub.io/#_rollout_strategies_and_targeting_rules[core documentation].

We are actively working on supporting client side evaluation of
strategies in the future releases as this scales better when you have 10000+ consumers.

=== Coding for Rollout strategies 
There are several preset strategies rules we track specifically: `user key`, `country`, `device` and `platform`. However, if those do not satisfy your requirements you also have an ability to attach a custom rule. Custom rules can be created as following types: `string`, `number`, `boolean`, `date`, `date-time`, `semantic-version`, `ip-address`

FeatureHub SDK will match your users according to those rules, so you need to provide attributes to match on in the SDK:

**Sending preset attributes:**

Provide the following attribute to support `userKey` rule:

[source,java]
----
cfr.clientContext().userKey("ideally-unique-id").build(); 
----


to support `country` rule:

[source,java]
----
cfr.clientContext().country(StrategyAttributeCountryName.NewZealand).build();
----

to support `device` rule:

[source,java]
----
cfr.clientContext().device(StrategyAttributeDeviceName.Browser).build();
----

to support `platform` rule:

[source,java]
----
cfr.clientContext().platform(StrategyAttributePlatformName.Android).build();
----

to support `semantic-version` rule:

[source,java]
----
cfr.clientContext().version("1.2.0").build(); 
----

or if you are using multiple rules, you can combine attributes as follows:

[source,java]
----
cfr.clientContext().userKey("ideally-unique-id")
      .country(StrategyAttributeCountryName.NewZealand)
      .device(StrategyAttributeDeviceName.Browser)
      .platform(StrategyAttributePlatformName.Android)
      .version("1.2.0")
      .build();  
----

The `build()` method will trigger the regeneration of a special header (`x-featurehub`). This in turn
will automatically retrigger a refresh of your events if you have already connected (unless you are using polling
client that is not set up to do this (such as the OkHttp Android client)).

**Sending custom attributes:**

To add a custom key/value pair, use `attr(key, value)`

[source,java]
----
    cfr.clientContext.attr("first-language", "russian").build();
----

Or with array of values (only applicable to custom rules):

[source,java]
----
cfr.clientContext.attrs(“languages”, Arrays.asList(“russian”, “english”, “german”)).build();
----


You can also use `cfr.clientContext.clear()` to empty your context.

In all cases, you need to call `build()` to re-trigger passing of the new attributes to the server for recalculation.


**Coding for percentage splits:**
For percentage rollout you are only required to provide the `userKey` or `sessionKey`.

[source,java]
----
cfr.clientContext().userKey("ideally-unique-id").build(); 
----
or

[source,java]
----
cfr.clientContext().sessionKey("session-id").build(); 
----

For more details on percentage splits and feature experiments see https://docs.featurehub.io/#_percentage_split_rule[Percentage Split Rule].

== Feature Interceptors

Feature Interceptors are the ability to intercept the request for a feature. They only operate in imperative state. For
an overview check out the https://docs.featurehub.io/#_feature_interceptors[Documentation on them].

We currently support two feature interceptors:

- `io.featurehub.client.interceptor.SystemPropertyValueInterceptor` - this will read properties from system properties
and if they match the name of a key (case significant) then they will return that value. You need to have specified a 
system property `featurehub.features.allow-override=true` 
- `io.featurehub.client.interceptor.OpenTracingValueInterceptor` - this will look into the baggage of the current OpenTracing
`Span` and determine if there is a feature key override there, and if so, use it. This is kept in a separate 
package (`io.featurehub.sdk:java-client-opentracing:[1.1, 2)`) as it brings in extra dependencies. If you are using it, we
recommend bringing it into the client as well as there is a `io.featurehub.client.OpenTracingFeatureStateInjector` class
that can insert the baggage into the span on the client side. This interceptor will turn itself off unless `featurehub.opentracing-enabled=true` 
is configured in the system properties. This allows you to code it in and control it taking effect at runtime. We recommend
if you add this interceptor in, always disallow overrides for locked features. 

If you wish to test out the OpenTracing feature overrides, you can do so from the example Java application. Instructions
are there on how to do this.


